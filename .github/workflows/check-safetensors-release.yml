name: Check Safetensors Release

on:
  schedule:
    - cron: '0 0 * * *' # every day at 00:00 UTC
  workflow_dispatch: # allow manual trigger
    inputs:
      test_mode:
        description: 'Test mode: Create issue regardless of version check result'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  issues: write
  pull-requests: read

jobs:
  check-release:
    name: Check for new safetensors release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read current version from VERSION_BINDING.md
        id: current_version
        run: |
          VERSION_LINE=$(grep -E "^This repository is bound to safetensors v" VERSION_BINDING.md || echo "")
          if [ -z "$VERSION_LINE" ]; then
            echo "Could not find version in VERSION_BINDING.md"
            exit 1
          fi
          CURRENT_VERSION=$(echo "$VERSION_LINE" | sed -E 's/.*v([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          if [ -z "$CURRENT_VERSION" ] || ! echo "$CURRENT_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Failed to extract valid version number from: $VERSION_LINE"
            exit 1
          fi
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Get latest safetensors release
        id: latest_release
        run: |
          LATEST_RELEASE=$(curl -s https://api.github.com/repos/huggingface/safetensors/releases/latest | jq -r '.tag_name // .name' | sed 's/^v//')
          if [ -z "$LATEST_RELEASE" ] || [ "$LATEST_RELEASE" = "null" ]; then
            echo "Failed to get latest release"
            exit 1
          fi
          if ! echo "$LATEST_RELEASE" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+'; then
            echo "Invalid version format: $LATEST_RELEASE"
            exit 1
          fi
          echo "latest=$LATEST_RELEASE" >> $GITHUB_OUTPUT
          echo "Latest release: $LATEST_RELEASE"

      - name: Compare versions
        id: version_check
        run: |
          CURRENT="${{ steps.current_version.outputs.current }}"
          LATEST="${{ steps.latest_release.outputs.latest }}"
          
          # Parse version number (major.minor.patch)
          CURRENT_MAJOR=$(echo "$CURRENT" | cut -d. -f1)
          CURRENT_MINOR=$(echo "$CURRENT" | cut -d. -f2)
          LATEST_MAJOR=$(echo "$LATEST" | cut -d. -f1)
          LATEST_MINOR=$(echo "$LATEST" | cut -d. -f2)
          
          # Validate that major and minor are numeric
          if ! echo "$CURRENT_MAJOR" | grep -qE '^[0-9]+$' || ! echo "$CURRENT_MINOR" | grep -qE '^[0-9]+$'; then
            echo "Invalid current version components: major=$CURRENT_MAJOR, minor=$CURRENT_MINOR"
            exit 1
          fi
          if ! echo "$LATEST_MAJOR" | grep -qE '^[0-9]+$' || ! echo "$LATEST_MINOR" | grep -qE '^[0-9]+$'; then
            echo "Invalid latest version components: major=$LATEST_MAJOR, minor=$LATEST_MINOR"
            exit 1
          fi
          
          echo "Current: $CURRENT (major=$CURRENT_MAJOR, minor=$CURRENT_MINOR)"
          echo "Latest: $LATEST (major=$LATEST_MAJOR, minor=$LATEST_MINOR)"
          
          # Check if major or minor version has changed
          if [ "$LATEST_MAJOR" -gt "$CURRENT_MAJOR" ] || \
             ([ "$LATEST_MAJOR" -eq "$CURRENT_MAJOR" ] && [ "$LATEST_MINOR" -gt "$CURRENT_MINOR" ]); then
            echo "needs_update=true" >> $GITHUB_OUTPUT
            echo "Version update detected: $CURRENT -> $LATEST"
          else
            echo "needs_update=false" >> $GITHUB_OUTPUT
            echo "No significant version change detected"
          fi

      - name: Get release details
        if: steps.version_check.outputs.needs_update == 'true' || github.event.inputs.test_mode == 'true'
        id: release_details
        run: |
          RELEASE_DATA=$(curl -s https://api.github.com/repos/huggingface/safetensors/releases/latest)
          RELEASE_URL=$(echo "$RELEASE_DATA" | jq -r '.html_url')
          RELEASE_BODY=$(echo "$RELEASE_DATA" | jq -r '.body' | head -n 50)
          RELEASE_DATE=$(echo "$RELEASE_DATA" | jq -r '.published_at')
          RELEASE_TAG=$(echo "$RELEASE_DATA" | jq -r '.tag_name')
          
          # Validate extracted data
          if [ "$RELEASE_URL" = "null" ] || [ -z "$RELEASE_URL" ]; then
            echo "Failed to get release URL"
            exit 1
          fi
          if [ "$RELEASE_DATE" = "null" ] || [ -z "$RELEASE_DATE" ]; then
            echo "Failed to get release date"
            exit 1
          fi
          if [ "$RELEASE_TAG" = "null" ] || [ -z "$RELEASE_TAG" ]; then
            echo "Failed to get release tag"
            exit 1
          fi
          if [ "$RELEASE_BODY" = "null" ]; then
            RELEASE_BODY="No release notes available"
          fi
          
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT

      - name: Check if upstream branch exists
        if: steps.version_check.outputs.needs_update == 'true' || github.event.inputs.test_mode == 'true'
        id: check_branch
        run: |
          LATEST_VERSION="${{ steps.latest_release.outputs.latest }}"
          TEST_MODE="${{ github.event.inputs.test_mode }}"
          
          # Add suffix for test mode
          if [ "$TEST_MODE" = "true" ]; then
            BRANCH_NAME="upstream/v${LATEST_VERSION}-test"
          else
            BRANCH_NAME="upstream/v${LATEST_VERSION}"
          fi
          
          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Branch $BRANCH_NAME already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Branch $BRANCH_NAME does not exist, will be created"
          fi
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create upstream branch with upstream code
        if: (steps.version_check.outputs.needs_update == 'true' || github.event.inputs.test_mode == 'true') && steps.check_branch.outputs.exists == 'false'
        run: |
          LATEST_VERSION="${{ steps.latest_release.outputs.latest }}"
          RELEASE_TAG="${{ steps.release_details.outputs.release_tag }}"
          TEST_MODE="${{ github.event.inputs.test_mode }}"
          
          # Add suffix for test mode
          if [ "$TEST_MODE" = "true" ]; then
            BRANCH_NAME="upstream/v${LATEST_VERSION}-test"
            echo "üß™ Test mode: Creating test branch ${BRANCH_NAME}"
          else
            BRANCH_NAME="upstream/v${LATEST_VERSION}"
            echo "Creating branch ${BRANCH_NAME}"
          fi
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add upstream remote if it doesn't exist
          if ! git remote | grep -q "^upstream$"; then
            echo "Adding upstream remote..."
            git remote add upstream https://github.com/huggingface/safetensors.git
          else
            echo "Upstream remote already exists, updating..."
            git remote set-url upstream https://github.com/huggingface/safetensors.git
          fi
          
          # Fetch upstream tags and branches
          echo "Fetching upstream tags and branches..."
          git fetch upstream --tags
          
          # Check if the tag exists
          # Note: git fetch --tags stores tags as local tags, not with upstream/ prefix
          if ! git rev-parse --verify "${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Error: Tag ${RELEASE_TAG} not found in upstream repository"
            exit 1
          fi
          
          # Create new branch from upstream tag
          # This creates a branch pointing to the upstream tag commit
          # Note: tags fetched from upstream are stored as local tags without upstream/ prefix
          echo "Creating branch ${BRANCH_NAME} from upstream tag ${RELEASE_TAG}..."
          git checkout -b "$BRANCH_NAME" "${RELEASE_TAG}"
          
          # Push the branch to origin
          echo "Pushing branch ${BRANCH_NAME} to origin..."
          git push origin "$BRANCH_NAME"
          
          echo "Successfully created and pushed branch ${BRANCH_NAME} with upstream code from ${RELEASE_TAG}"

      - name: Check for existing issue
        if: steps.version_check.outputs.needs_update == 'true' || github.event.inputs.test_mode == 'true'
        id: existing_issue
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'safetensors-version-update'
            });
            
            const latestVersion = '${{ steps.latest_release.outputs.latest }}';
            const existingIssue = issues.find(issue => 
              issue.title.includes(`Version Update Alert:`) && 
              issue.title.includes(`-> v${latestVersion}`)
            );
            
            if (existingIssue) {
              core.setOutput('issue_number', existingIssue.number);
              core.setOutput('exists', 'true');
            } else {
              core.setOutput('exists', 'false');
            }

      - name: Create or update issue
        id: create_issue
        if: (steps.version_check.outputs.needs_update == 'true' || github.event.inputs.test_mode == 'true') && steps.existing_issue.outputs.exists == 'false'
        uses: actions/github-script@v7
        env:
          RELEASE_BODY: ${{ steps.release_details.outputs.release_body }}
          TEST_MODE: ${{ github.event.inputs.test_mode }}
        with:
          script: |
            const currentVersion = '${{ steps.current_version.outputs.current }}';
            const latestVersion = '${{ steps.latest_release.outputs.latest }}';
            const releaseUrl = '${{ steps.release_details.outputs.release_url }}';
            const releaseDate = '${{ steps.release_details.outputs.release_date }}';
            const releaseBody = process.env.RELEASE_BODY;
            const isTestMode = process.env.TEST_MODE === 'true';
            
            const testPrefix = isTestMode ? 'üß™ [TEST] ' : '';
            const title = `${testPrefix}üö® Safetensors Version Update Alert: v${currentVersion} -> v${latestVersion}`;
            const branchName = isTestMode 
              ? `upstream/v${latestVersion}-test` 
              : `upstream/v${latestVersion}`;
            
            const bodyLines = [
              '## Version Update Detected',
              '',
              isTestMode ? '> **‚ö†Ô∏è This is a TEST MODE issue and can be deleted**' : '',
              'A new version of HuggingFace safetensors has been released!',
              '',
              '### Version Information',
              `- **Current Bound Version**: v${currentVersion}`,
              `- **Latest Release Version**: v${latestVersion}`,
              `- **Release Date**: ${releaseDate}`,
              '',
              '### Related Links',
              `- [Release Page](${releaseUrl})`,
              '- [Upstream Repository](https://github.com/huggingface/safetensors)',
              '',
              '### Release Notes',
              '```',
              releaseBody,
              '```',
              '',
              '### Upstream Branch',
              '',
              'An upstream branch has been automatically created with the upstream code:',
              `- **Branch**: \`${branchName}\``,
              '',
              isTestMode 
                ? '### ‚ö†Ô∏è TEST MODE - No Action Required\n\n**This is a test issue. Please do not make any changes.** This issue is for testing purposes only and can be safely ignored or deleted.'
                : [
                    '### Tasks',
                    '',
                    'Please perform the following tasks to integrate the new safetensors version:',
                    '',
                    '#### 1. Analyze Changes Between Versions',
                    '',
                    `- Compare the differences between safetensors v${currentVersion} and v${latestVersion}`,
                    '- Review the upstream branch to understand what has changed',
                    '- Identify all modifications, additions, and deletions',
                    '',
                    '#### 2. Integrate Changes Carefully',
                    '',
                    '**‚ö†Ô∏è CRITICAL: Preserve cryptotensors functionality**',
                    '',
                    'When integrating upstream changes, you must:',
                    '',
                    '- **Preserve all cryptotensors encryption/decryption functionality**',
                    '- **Maintain all custom features and modifications**',
                    '- **Keep the cryptotensors-specific code intact**',
                    '- **Do not overwrite or remove any cryptotensors enhancements**',
                    '',
                    '#### 3. Handle Uncertain Cases',
                    '',
                    'If you encounter changes that might conflict with cryptotensors functionality:',
                    '',
                    '- **Document the conflict** in the PR description',
                    '- **Flag the issue** for manual review',
                    '- **Do not proceed** if you are uncertain about the impact',
                    '- **Ask for clarification** rather than making assumptions',
                    '',
                    '#### 4. Update Version Binding',
                    '',
                    `- Update \`VERSION_BINDING.md\` to reflect the new version v${latestVersion}`,
                    '',
                    '#### 5. Create Pull Request',
                    '',
                    '- Create a pull request with all the integrated changes',
                    '- Include a detailed description of what was changed',
                    '- Reference this issue in the PR',
                    '',
                    '### Important Notes',
                    '',
                    '- This repository is a fork/modification of safetensors with added encryption capabilities',
                    '- The goal is to stay in sync with upstream while preserving cryptotensors features',
                    '- When in doubt, preserve existing functionality and ask for guidance',
                  ].join('\n'),
              '',
              '---',
              `*This issue was automatically created by GitHub Actions${isTestMode ? ' in TEST MODE' : ''}*`,
            ].filter(Boolean);
            const body = bodyLines.join('\n');

            const labels = ['safetensors-version-update', 'automated'];
            if (isTestMode) {
              labels.push('test');
            }

            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: labels
            });
            
            core.setOutput('issue_number', issue.number);

      - name: Assign issue to GitHub Copilot Agent
        # This step runs when:
        # 1. A version update is detected (needs_update == 'true'), OR
        # 2. Test mode is enabled (test_mode == 'true')
        # In both cases, the issue will be assigned to the Copilot Agent to generate a PR
        if: (steps.version_check.outputs.needs_update == 'true' || github.event.inputs.test_mode == 'true') && steps.existing_issue.outputs.exists == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.create_issue.outputs.issue_number }};
            // Default to 'copilot' (GitHub Copilot Coding Agent), can be overridden via repository variable COPILOT_AGENT
            // If vars.COPILOT_AGENT is not set, it will be empty string, so we use the default
            const customAgent = '${{ vars.COPILOT_AGENT }}'.trim();
            const copilotAgent = customAgent || 'copilot';
            
            try {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                assignees: [copilotAgent]
              });
              console.log(`Assigned issue #${issueNumber} to ${copilotAgent}`);
            } catch (error) {
              console.warn(`Failed to assign issue to ${copilotAgent}: ${error.message}`);
              console.warn('This is not critical - the issue was still created successfully.');
            }

      - name: Comment on existing issue
        if: (steps.version_check.outputs.needs_update == 'true' || github.event.inputs.test_mode == 'true') && steps.existing_issue.outputs.exists == 'true'
        uses: actions/github-script@v7
        env:
          TEST_MODE: ${{ github.event.inputs.test_mode }}
        with:
          script: |
            const issueNumber = ${{ steps.existing_issue.outputs.issue_number }};
            const latestVersion = '${{ steps.latest_release.outputs.latest }}';
            const releaseDate = '${{ steps.release_details.outputs.release_date }}';
            const isTestMode = process.env.TEST_MODE === 'true';
            
            const testPrefix = isTestMode ? 'üß™ [TEST MODE] ' : '';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `${testPrefix}üîÑ Version v${latestVersion} is still available (${releaseDate}). Please check if an update is needed.`
            });

